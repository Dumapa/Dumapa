#11111111111111111
a = int(input())
for x in range(1,a+1):
    print(x**2)

#22222222222222222
a = int(input())
b = []
for x in range (a+1):
     if x % 2 == 0:
         b.append(str(x))
print(",".join(b))

#33333333333333333
a = int(input())
for x in range(a+1):
     if x % 12 == 0:
         print(x, end= " ")

#44444444444444444
a = list(map(int, input().split()))
for x in range(a[0],a[1]+1):
     print(x**2)

#55555555555555555
a = int(input())
for x in range(a,-1,-1):
     print(x)

#66666666666666666
n = int(input())
def pelmeni(a):
    if a == 0:
        return ""
    elif a == 1:
        return "1"
    
#7777777777777777
class Reverse:
    def __init__(self, data):
        self.data = data
        self.index = len(data) - 1

    def __iter__(self):
        return self

    def __next__(self):
        if self.index < 0:
            raise StopIteration
        result = self.data[self.index]
        self.index -= 1
        return result

s = input()
rev_iter = Reverse(s)
for char in rev_iter:
    print(char, end="")

#88888888888888888
def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

def prime_generator(n):
    for i in range(1, n + 1):
        if is_prime(i):
            yield str(i)

val = input().strip()

print(" ".join(prime_generator(n)))

#999999999999999
def powers_of_two(n):
    for i in range(n + 1):
        yield str(2**i)

val = input()
print(" ".join(powers_of_two(n)))


#10101010101010101010
def limon(s,n):
    for x in range(int(n)):
        yield str(s)
a = str(input())
b = int(input())
print(" ".join(limon(a,b)))


#17 17 17 17 17 17 17 17 17
import math
def pirat(a,b,c):
    sum_floppa = 0
    if b[0] <= a and b[1] <= a:
        sum_floppa += math.sqrt(b[0]**2 + b[1]**2)
    if c[0] <= a and c[1] <= a:
        sum_floppa += math.sqrt(c[0]**2 + c[1]**2)
    return sum_floppa * 1.0000000000
p = int(input())


#11 11 11 11 11 11 11 11 11 11 11
import json
x = json.loads(input())
y = json.loads(input())
def row(source , patch):
    if not isinstance(patch,dict):
        return patch
    if not isinstance(source,dict):
        source = {}
    for k,v in patch.items():
        if v is None:
            source.pop(k,None)
        else:
            source[k] = row(source.get(k), v)
    return source
result = row(x,y)
r = list(map(int, input().split()))
k = list(map(int, input().split()))
print(f"{pirat(p,r,k)}.:10f")

#12 12 12 12 12 12 12 12 12 12 12 12
import json
def change(a,b,path=""):
    if a == b:
        return
    if isinstance(a,dict) and isinstance(b,dict):
        for k in sorted(set(a) | set(b)):
            new_path =f"{path}.{k}" if path else k
            yield from change(a.get(k, "<missing>"), b.get(k, "<missing>") , new_path)
    else:
        def final(v):
            return "<missing>" if v == "<missing>" else json.dumps(v, separators = (',',':'))
        yield f"{path} : {final(a)} -> {final(b)}"
x,y = json.loads(input()), json.loads(input())
differences = list(change(x,y))
if not differences:
    print("No differences")
else:
    print("\n".join(sorted(differences)))
 
#13 13 13 13 13 13 13 13 13 13 13 13
import json
source = json.loads(input().strip())
n = int(input())
keys = []
for j in range(n):
    k = []
    a = input()
    i = 0
    item = ""
    while i < len(a):
        if a[i] == "." or a[i] == "[":
            if a[i] == "[":
                if item:
                    k.append(("key", item))
                    item = ""
                i += 1
                ind = ""
                while a[i] != "]":
                    ind += a[i]
                    i += 1
                i += 1
                k.append(("index", int(ind)))
            else: 
                if item:
                    k.append(("key", item))
                    item = ""
                i += 1
        else:
            item += a[i]
            i += 1
    if item:
        k.append(("key", item))
    keys.append(k)

for s in keys:
    cur = source
    found = True
    for typ, val in s:
        if typ == 'key':
            if isinstance(cur, dict) and val in cur:
                cur = cur[val]
            else: 
                found = False
                break
        else:
            if isinstance(cur, list) and 0 <= val < len(cur):
                cur = cur[val]
            else:
                found = False
                break
    if found:
            print(json.dumps(cur, separators=(',', ':')))
    else:
        print("NOT_FOUND")

#14 14 14 14 14 14 14 14 14 14 14  14 14 14 14 14 14 14 14 14 14 14 14
import sys
def get_total_seconds(line):
    # line: "2025-01-01 UTC+03:00"
    parts = line.split()
    y, m, d = map(int, parts[0].split('-'))
    off_str = parts[1][3:] # "+03:00"
    sign = 1 if off_str[0] == '+' else -1
    h_off = int(off_str[1:3])
    m_off = int(off_str[4:6])
    offset_sec = sign * (h_off * 3600 + m_off * 60)
    if m <= 2:
        y -= 1
        m += 12
    a = y // 100
    b = 2 - a + (a // 4)
    days_since_era = int(365.25 * (y + 4716)) + int(30.6001 * (m + 1)) + d + b - 1524
    return days_since_era * 86400 - offset_sec
input_data = sys.stdin.read().splitlines()
if len(input_data) >= 2:
    s1 = get_total_seconds(input_data[0])
    s2 = get_total_seconds(input_data[1])
    floor(|delta| / 86400)
    print(abs(s1 - s2) // 86400)

#15 15 15 15 15 15 151 51 115 15 151
def seconds(a):
    y, m, d = map(int, a[0].split("-"))
    if m < 3: y -= 1; m += 12
    days = y*365 + y//4 - y//100 + y//400 + (153*m + 8)//5 + d
    tz = a[1][3:]
    s = 1 if tz[0] == '+' else -1
    return days * 86400 - s * (int(tz[1:3])*3600 + int(tz[4:6])*60)

c = input().split()
b = input().split()
print(abs(seconds(b) - seconds(c)) // 86400)
#16 16 16 16 16 16
import sys
from datetime import datetime, timezone, timedelta

def parse_time(s):
    # Format: YYYY-MM-DD HH:MM:SS UTC+HH:MM
    parts = s.strip().split()
    date_str = f"{parts[0]} {parts[1]}"
    tz_str = parts[2]
    
    # Parse offset
    offset_sign = 1 if '+' in tz_str else -1
    offset_parts = tz_str.replace('UTC+', '').replace('UTC-', '').split(':')
    hours = int(offset_parts[0])
    minutes = int(offset_parts[1])
    
    offset = timedelta(hours=hours, minutes=minutes) * offset_sign
    tz = timezone(offset)
    
    dt = datetime.strptime(date_str, "%Y-%m-%d %H:%M:%S")
    return dt.replace(tzinfo=tz)

def solve():
    lines = sys.stdin.readlines()
    if len(lines) < 2:
        return
    
    t1 = parse_time(lines[0])
    t2 = parse_time(lines[1])
    
    diff = int((t2 - t1).total_seconds())
    print(abs(diff))

if __name__ == "__main__":
    solve()
#17 17 17 17 17 17 17 17 17 17
import math
import sys

def solve():
    try:
        data = sys.stdin.read().split()
        if not data:
            return
        
        r = float(data[0])
        x1, y1 = float(data[1]), float(data[2])
        x2, y2 = float(data[3]), float(data[4])
    except (EOFError, IndexError):
        return

    dx = x2 - x1
    dy = y2 - y1
    
    a = dx**2 + dy**2
    b = 2 * (x1 * dx + y1 * dy)
    c = x1**2 + y1**2 - r**2
    
    if a == 0:
        if x1**2 + y1**2 <= r**2 + 1e-12:
            print(f"{0.0:.10f}")
        else:
            print(f"{0.0:.10f}")
        return

    det = b**2 - 4 * a * c
    
    if det < 0:
        print(f"{0.0:.10f}")
        return
    
    sqrt_det = math.sqrt(det)
    t1 = (-b - sqrt_det) / (2 * a)
    t2 = (-b + sqrt_det) / (2 * a)
    
    t_start = max(0.0, t1)
    t_end = min(1.0, t2)
    
    if t_start < t_end:
        res = (t_end - t_start) * math.sqrt(a)
        print(f"{res:.10f}")
    else:
        print(f"{0.0:.10f}")

if __name__ == "__main__":
    solve()
#18 #18 18181818
import sys

def solve_418():
    try:
        data = sys.stdin.read().split()
        if not data:
            return
        
        x1 = float(data[0])
        y1 = float(data[1])
        x2 = float(data[2])
        y2 = float(data[3])
    except (EOFError, IndexError):
        return

    y1_abs = abs(y1)
    y2_abs = abs(y2)
    
    if (y1_abs + y2_abs) == 0:
        res_x = x1
    else:
        res_x = x1 + (x2 - x1) * y1_abs / (y1_abs + y2_abs)
    
    print(f"{res_x:.10f} {0.0:.10f}")

if __name__ == "__main__":
    solve_418()

#18191919191991919119
import math
import sys

def solve():
    try:
        input_data = sys.stdin.read().split()
        if not input_data:
            return
        r = float(input_data[0])
        x1, y1 = float(input_data[1]), float(input_data[2])
        x2, y2 = float(input_data[3]), float(input_data[4])
    except (EOFError, IndexError):
        return

    dist_sq = (x2 - x1)**2 + (y2 - y1)**2
    dist = math.sqrt(dist_sq)
    
    if dist == 0:
        print(f"{0.0:.10f}")
        return

    d1_sq = x1**2 + y1**2
    d2_sq = x2**2 + y2**2
    d1 = math.sqrt(d1_sq)
    d2 = math.sqrt(d2_sq)

    cross_prod = abs(x1 * y2 - x2 * y1)
    h = cross_prod / dist
    
    dot1 = x1 * (x2 - x1) + y1 * (y2 - y1)
    dot2 = x2 * (x1 - x2) + y2 * (y1 - y2)

    if h >= r or dot1 >= 0 or dot2 >= 0:
        print(f"{dist:.10f}")
    else:
        gamma = math.acos((x1 * x2 + y1 * y2) / (d1 * d2))
        alpha = math.acos(r / d1)
        beta = math.acos(r / d2)
        
        arc_len = r * (gamma - alpha - beta)
        l1 = math.sqrt(d1_sq - r**2)
        l2 = math.sqrt(d2_sq - r**2)
        
        print(f"{l1 + l2 + arc_len:.10f}")

if __name__ == "__main__":
    solve()

#202020202020200220
import sys

def solve():
    input_data = sys.stdin.read().split()
    if not input_data:
        return
    
    n = int(input_data[0])
    g = 0
    non_local_n = 0
    
    idx = 1
    for _ in range(n):
        if idx + 1 >= len(input_data):
            break
        scope = input_data[idx]
        value = int(input_data[idx + 1])
        
        if scope == "global":
            g += value
        elif scope == "nonlocal":
            non_local_n += value
        
        idx += 2
        
    print(f"{g} {non_local_n}")

if __name__ == "__main__":
    solve()

#21212121212121212121
import sys
import importlib

def solve():
    input_data = sys.stdin.read().split()
    if not input_data:
        return
    
    try:
        q = int(input_data[0])
    except ValueError:
        return
        
    idx = 1
    for _ in range(q):
        if idx + 1 >= len(input_data):
            break
        
        module_path = input_data[idx]
        attr_name = input_data[idx + 1]
        idx += 2
        
        try:
            module = importlib.import_module(module_path)
        except ImportError:
            print("MODULE_NOT_FOUND")
            continue
            
        if not hasattr(module, attr_name):
            print("ATTRIBUTE_NOT_FOUND")
            continue
            
        attr = getattr(module, attr_name)
        if callable(attr):
            print("CALLABLE")
        else:
            print("VALUE")

if __name__ == "__main__":
    solve()
